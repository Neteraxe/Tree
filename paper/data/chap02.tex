% !TeX root = ../Tree.tex
\chapter{搜索树}
\section{指针与地址}

树中不可避免地使用指针。Donald Knuth曾指出：“赋值语句和指针变量是‘最宝贵的财富’”\cite{10.1145/356635.356640}。指针是许多编程语言中用来存储内存地址的对象。这可以是位于计算机内存中的另一个地址值的值，或者在某些情况下，内存映射的计算机硬件的值。指针引用内存中的一个位置，而获取存储在该位置的值称为取消引用(dereference)指针\cite{enwiki:1015276279}。

一个数据原语（data primitive）（或者仅仅是原语）是任何可以通过一次内存访问从计算机内存读取或写入计算机内存的数据（例如，一个字节和一个字都是原语）。

数据聚合（data aggregate）（或仅聚合）是一组在内存中逻辑上连续的基本体，它们被视为一个数据集（例如，聚合可以是3个逻辑上连续的字节，其值表示空间中某个点的3个坐标）。当一个聚合完全由相同类型的基元组成时，该聚合可以称为数组；在某种意义上，多字节字原语是一个字节数组，有些程序就是这样使用字的。

在这些定义的上下文中，字节是最小的原语；每个内存地址指定一个不同的字节。数据的初始字节的内存地址被认为是整个数据的内存地址（或基内存地址）。一个内存指针（或者仅仅是指针）是一个原语，它的值被用作内存地址；这意味着指针指向内存地址。也可以说，当指针的值是数据的内存地址时，指针指向[内存中的]数据。

指针是在大多数现代体系结构提供的寻址功能之上的一个非常精简的抽象。在最简单的方案中，地址或数字索引被分配给系统中的每个内存单元，其中该单元通常是一个字节或一个字（取决于体系结构是字节可寻址还是字可寻址），有效地将所有内存转换为一个非常大的数组。然后，系统还将提供一个操作来检索存储在给定地址的内存单元中的值（通常使用机器的通用寄存器）。

在通常情况下，指针的大小足以容纳比系统内存单元更多的地址。这就引入了一种可能性，即程序可能会试图访问一个地址，而该地址不对应于任何内存单元，这可能是因为没有安装足够的内存（即超出可用内存的范围），也可能是因为体系结构不支持这样的地址。在某些平台（如Intel x86体系结构）中，第一种情况可能称为分段故障（segfault）。第二种情况在AMD64的当前实现中是可能的，其中指针是64位长，地址只扩展到48位。指针必须符合某些规则（规范地址），因此如果非规范指针被取消引用(dereference)，处理器将引发一般性保护错误。

数据结构通常基于计算机在其内存中的任何位置获取和存储数据的能力，这些数据结构由一个指针（一个表示内存地址的位字符串）指定，它本身可以存储在内存中并由程序操作。因此，数组和记录数据结构基于通过算术运算计算数据项的地址，而链接数据结构基于在结构本身中存储数据项的地址。\cite{enwiki:1025932291}

\section{树与链表}

定义链表即定义一个数据聚合结构，应首先定义另一个数据聚合结构“结点”从而使用对应的指针，然后通过链表的头尾指针将结点串在一起。在链表结点中，应使用指针存储前后链表结点的基地址。

1857年，英国数学家Arthur Cayley创造了“树”\cite{enwiki:1017966184}这个名词。树的名词来源于图论中的直接应用，在图论中，树被定义为一个满足任意两个顶点被“一条确定的边”相连的无向图，或等价于一个连通的无环无向图。而“森林”定义为一个满足两个顶点被“至多一条确定的边”相连的无向图，或等价于一个无环无向图，或等价于树的不相交并集。数据结构中的树直接来源于图论。

因为树是无环无向图的原因，树常常比图数据结构更容易考虑。

在图论中，路径图(path graph)\cite{enwiki:1005960330}，又称线性图(linear graph)，由在一条线上的n个顶点组成，其顶点$V_1$与$V_n$被属于$i=1,2, ... ,n-1$的边$\{v_i, v_{i+1}\}$相连。这与链表十分相似，但链表的结点具有数据，且至多有两个指针（线性图是一种树，因此是无向图）。

而线性列表实际上也是一种数据结构上的树。但数据结构中的树的父子结点之间的边的方向是“不固定的”，可以有特定个指针，而数学中的树，一定是无向图。因此，可以说链表是一种特殊的“一叉树”。


\section{二叉树与二叉搜索树}

数据结构中的树是著名的非线性数据结构。树可以用基本数据结构（链表，数组）的形式实现，因此，我们不会认为链表是一棵树。当我们考虑多路树（multi-way tree）时，我们首先考虑一种最简单的多路树，但亦彰显了树与基本数据结构不同的树，即二叉树（binary tree）。而一切有根有序的多叉树，都可以等价地转换并实现为二叉树。

二叉树可以使用集合论概念进行递归定义：

（非空）二叉树是元组$(L,S,R)$，其中$L$和$R$是二叉树或空集，$S$是包含根的单例集。

在数学中，元组是元素的有限有序列表（序列）。$n$元组是$n$个元素的序列（或有序列表），其中$n$是非负整数。只有一个$0$元组，称为空元组。一个单例集，也称为单位集，是一个只有一个元素的集合。例如，集合$\{null\}$ 是包含元素$null$的单例。这样定义从而限定了二叉树的的左右子树。

通过二叉树的递归定义及其他树的定义推论可知，树与递归以及集合论有很明确的联系。而二叉树的二分实现，也使二叉搜索树的查找时间复杂度最好为$O(log_2n)$。在特殊情况下，二叉树退化为类链表形式，查找时间复杂度为$O(n)$。

二叉搜索树（BST）\cite{enwiki:1027048298}也称为有序或排序二叉树，是一种根二叉树，其内部节点存储的键大于节点左子树中的所有键，小于节点右子树中的所有键。二叉树是一种以有组织的方式存储数字等数据的数据结构。二进制搜索树允许二进制搜索快速查找、添加和删除数据项，并可用于实现动态集和查找表。BST中节点的顺序意味着每次比较都会跳过剩余树的一半，因此整个查找所需的时间与树中存储的项数的二元对数成正比。这比在（未排序的）数组中按键查找项所需的线性时间要好得多，但比哈希表上相应的操作要慢。

\section{二叉树的遍历与线索二叉树}

以下是离散数学中对有根树$T=(V,E)$的所有顶点和根$r$多个顺序遍历的递归定义：

\begin{enumerate}
	\item 如果$T$中仅有一个顶点$r$，$r$本身构成$T$的前序，后序及中序遍历。
	\item 其他情况下，设$T_1,......T_n$为$T$从左到右的子树。
	\begin{itemize}
		\item 前序遍历：$Pre(T)=r,Pre(T_1),......,Pre(T_n)$
		\item 后序遍历：$Post(T)=Post(T_1),......,Post(T_n),r$
		\item 中序遍历(仅$n=2$时二叉树情况存在，此时设$T$的左子树为$T_L$，右子树为$T_R$)：$In(T)=In(T_L),r,In(T_R)$
	\end{itemize}
\end{enumerate}

在1968年的一本教科书中，Donald Knuth询问是否存在一种顺序遍历的非递归算法，该算法不使用堆栈，并且不修改树。这个问题的解决方案之一来自1979年的J.H.Morris。在1969年的后续版本中，Knuth将线程树表示法归因于Perlis和Thornton。

二叉树的线程（线索）化是通过使所有右子指针（通常为空）指向节点的顺序遍历后继对象（如果存在），而所有左子指针（通常为空）指向节点的顺序遍历前继对象来实现的。

在二叉树的线索化中，可以选择任何一种顺序遍历方法。线索二叉树有助于二叉树按特定顺序进行遍历。


\section{自平衡二叉搜索树，Red-Black树， AVL树}

自平衡（或高度平衡）二叉搜索树是任何基于节点的二叉搜索树，它在面对任意项目的插入和删除时自动保持其高度（根下的最大级别数）较小（Donald Knuth，1988）\cite{enwiki:1002026252}。

高度为$h$的二叉树最多可包含$2^{h+1}-1$个节点。仅由根节点组成的树的高度为0。因此，对于任何具有$n$个节点和高度$h$的树：
$$n \leq 2^{h+1}-1$$
对等式两边+1，取对数后减去1可得:
$$h \geq \lceil \log _{2}(n+1)-1\rceil \geq \lfloor \log _{2}n\rfloor$$
可知BST的最小高度为$\log_{2}(n)$

然而，当项目按排序键顺序插入时，树将退化为具有n个节点的链表。

自平衡二叉树通过在键插入时对树执行变换（如树旋转）来解决此问题，以保持高度与$log_2{n}$成比例。尽管涉及到一定的开销，但从长远来看，通过确保后期操作的快速执行，这可能是合理的。

AVL树\cite{enwiki:1026867024}是以两位苏联发明家乔治·阿德尔森·维尔斯基（Georgy Adelson Velsky）和叶夫根尼·兰迪斯（Evgenii Landis）的名字命名(Adelson-Velsky and Landis)的，他们在1962年的论文《信息组织的算法》（An algorithm for The organization of information）中发表了这一树。AVL树是历史上第一个自平衡二叉树。所有AVL结点使用以下平衡因子(balance factor)：
$$BF(X):=Height(RightSubTree(X))-Height(LeftSubtree(X))$$

:=是=的变体，通常在程序语言的数学中使用，表示赋值。通常=用以表示相等。

红黑树是一种自平衡二叉搜索树。每个节点存储一个表示“color”（“red”或“black”）的额外位，用于确保树在插入和删除期间保持平衡。1972年，Rudolf Bayer发明了一种数据结构，它是B树的一个特殊的4阶情况。这些树以相同的节点数保持从根到叶的所有路径，从而创建完全平衡的树。然而，它们不是二叉搜索树。拜耳在他的论文中称之为“对称二叉B树”，后来它们成为流行的2-3-4树或2-4树。这种树的B树性质使得2-3-4树是红黑树的同构，这意味着它们是等价的数据结构。换句话说，对于每2–3–4树，至少存在一个具有相同顺序的数据元素的红黑树。此外，2–3–4树上的插入和删除操作会导致节点扩展、拆分和合并，相当于红黑树中的颜色翻转和旋转。然而，2-3-4树很难在大多数编程语言中实现，因为树上的操作涉及大量的特殊情况。红-黑树更容易实现，因此倾向于使用。在1978年的一篇论文《平衡树的二色框架》中，Leonidas J。Guibas和Robert Sedgewick从对称二叉B-树中导出了红黑树\cite{enwiki:1027677404}。

红黑树是满足下列性质的树：

\begin{enumerate}
	\item 每个节点不是红色就是黑色。
	\item 所有的NIL叶子都被认为是黑色的。
	\item 如果一个节点是红色的，那么它的两个子节点都是黑色的。
	\item 从一个给定节点到它的任何后代NIL叶子的每一条路径都经过相同数量的黑色节点。
\end{enumerate}



